<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Anonyme Nachrichten</title>
  <style>
    :root { --accent:#0066cc; --muted:#666; --bg:#f7f8fb; }
    body { font-family: Inter, system-ui, Arial; background:var(--bg); color:#111; margin:0; padding:28px; display:flex; justify-content:center; }
    .wrap { width:100%; max-width:760px; }
    .card { background:#fff; border-radius:12px; padding:22px; box-shadow:0 6px 18px rgba(20,20,40,.06); }
    h1 { margin:0 0 12px 0; font-size:20px; }
    .owner { font-weight:700; margin-bottom:8px; }
    .small { color:var(--muted); font-size:13px; margin-bottom:8px; }
    textarea { width:100%; min-height:120px; padding:12px; font-size:15px; border-radius:8px; border:1px solid #e6e9ef; resize:vertical; box-sizing:border-box; }
    .row { display:flex; gap:10px; align-items:center; margin-top:12px; }
    button { background:var(--accent); color:#fff; border:none; padding:10px 14px; border-radius:8px; cursor:pointer; font-weight:600; }
    button[disabled] { opacity:.6; cursor:not-allowed; }
    .hidden { display:none !important; }
    .char { color:var(--muted); font-size:13px; }
    .error { color:#b00020; margin-top:10px; font-size:14px; }
    .copybox { margin-top:14px; padding:12px; border:1px dashed #cfcfcf; border-radius:8px; background:#fbfbff; cursor:pointer; white-space:pre-wrap; word-break:break-word; }
    /* Toast */
    .toast { position:fixed; right:20px; bottom:20px; background:#111; color:#fff; padding:12px 16px; border-radius:10px; box-shadow:0 8px 30px rgba(0,0,0,.2); opacity:0; transform:translateY(12px); transition:all .26s ease; pointer-events:none; z-index:9999; }
    .toast.show { opacity:1; transform:translateY(0); pointer-events:auto; }
    .note { font-size:13px; color:var(--muted); margin-top:10px; }
  </style>

  <!-- Cloudflare Turnstile -->
  <script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer></script>
</head>
<body>
  <div class="wrap">
    <div class="card" id="card">
      <h1 id="title">Anonyme Nachrichten</h1>
      <div id="ownerLine" class="owner">Lade...</div>
      <div id="cfgError" class="error hidden"></div>

      <div id="formArea" class="hidden">
        <div class="small">Deine anonyme Nachricht an <span id="ownerName"></span>:</div>
        <textarea id="message" placeholder="Schreibe deine Nachricht (mind. 3, max. 200 Zeichen)"></textarea>
        <div style="display:flex; justify-content:space-between; align-items:center; margin-top:8px;">
          <div class="char" id="charCount">0 / 200</div>
          <div id="turnstileWrapper"></div>
        </div>

        <div class="row">
          <button id="submitBtn" class="hidden">Absenden</button>
          <div id="sendingNote" class="small hidden">Sende…</div>
        </div>

        <div id="resultArea" class="hidden">
          <div class="small">Gesendet — Klick zum Kopieren:</div>
          <div id="sentBox" class="copybox" title="Klicken, um zu kopieren"></div>
        </div>

        <div id="error" class="error hidden"></div>
        <div class="note">Hinweis: Neue Zeilen werden vor dem Versand in Leerzeichen umgewandelt.</div>
      </div>

    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script>
  (function(){
    // ------------------ KONFIGURATION ------------------
    const WORKER_URL = "https://weathered-tree-661a.anonymenachrichtholder.workers.dev";
    const TURNSTILE_SITEKEY = "0x4AAAAAACJjDP0IZOtMJtiL";
    // ---------------------------------------------------

    // Elemente
    const ownerLine = document.getElementById("ownerLine");
    const ownerNameEl = document.getElementById("ownerName");
    const formArea = document.getElementById("formArea");
    const cfgError = document.getElementById("cfgError");
    const messageEl = document.getElementById("message");
    const charCount = document.getElementById("charCount");
    const submitBtn = document.getElementById("submitBtn");
    const sendingNote = document.getElementById("sendingNote");
    const resultArea = document.getElementById("resultArea");
    const sentBox = document.getElementById("sentBox");
    const errorEl = document.getElementById("error");
    const title = document.getElementById("title");
    const toast = document.getElementById("toast");
    const turnstileWrapper = document.getElementById("turnstileWrapper");

    let currentBezeichnung = null;
    let lastToken = null;
    let widgetId = null;

    // === Pfadermittlung: Query param 'path' hat Vorrang, sonst location.pathname === '/'
    function resolveRequestedPath() {
      const qs = new URLSearchParams(location.search);
      let p = qs.get('path');
      if (p) {
        try { p = decodeURIComponent(p); } catch(e) { /* ignore */ }
      } else {
        p = location.pathname;
      }
      p = (p || "").replace(/^\/+|\/+$/g, "");
      if (!p) p = "index";
      return p;
    }

    const requested = resolveRequestedPath();
    // build candidate filenames (unique)
    function buildVariants(name){
      const variants = [];
      if (name) variants.push(name);
      const lower = name.toLowerCase();
      if (!variants.includes(lower)) variants.push(lower);
      const cap = name.charAt(0).toUpperCase() + name.slice(1);
      if (!variants.includes(cap)) variants.push(cap);
      // ensure index at end as fallback
      if (!variants.includes("index")) variants.push("index");
      return variants;
    }

    // Versuche mehrere Dateinamen in logischer Reihenfolge
    async function fetchConfigWithVariants(name) {
      const variants = buildVariants(name);
      for (const v of variants) {
        const url = "/parent/" + encodeURIComponent(v) + ".json";
        try {
          const r = await fetch(url, {cache: "no-store"});
          if (r.ok) {
            const j = await r.json();
            // return both json and the variant used
            return { json: j, variant: v, url };
          }
        } catch (e) {
          // ignore network parse error for this variant and try next
        }
      }
      // nothing found
      throw new Error("notfound");
    }

    // Lade Konfiguration (mit Variants-Strategie)
    async function loadConfig() {
      ownerLine.textContent = "Lade…";
      try {
        const res = await fetchConfigWithVariants(requested);
        const cfg = res.json;
        if (!cfg || !cfg.owner || !cfg.bezeichnung) {
          ownerLine.textContent = "Ungültige Konfiguration";
          cfgError.textContent = "Die Konfigurationsdatei muss 'owner' und 'bezeichnung' enthalten.";
          cfgError.classList.remove("hidden");
          return;
        }
        currentBezeichnung = cfg.bezeichnung;
        ownerLine.textContent = `Anonyme Nachrichten an ${cfg.owner}`;
        ownerNameEl.textContent = cfg.owner;
        title.textContent = `Anonyme Nachrichten an ${cfg.owner}`;
        formArea.classList.remove("hidden");
        // Render Turnstile nachdem die Seite gültig ist
        renderTurnstile();
      } catch (e) {
        ownerLine.textContent = "Diese Seite ist nicht konfiguriert.";
        cfgError.textContent = `Konfigurationsdatei nicht gefunden für Pfad: ${requested} (versuchte Varianten: ${buildVariants(requested).join(", ")})`;
        cfgError.classList.remove("hidden");
      }
    }

    loadConfig();

    // Char counter & validation
    messageEl.addEventListener("input", () => {
      const val = messageEl.value;
      charCount.textContent = `${val.length} / 200`;
      validateAndToggleSubmit();
    });

    function validateAndToggleSubmit(){
      const txt = messageEl.value.trim();
      const okLen = txt.length >= 3 && txt.length <= 200;
      if (lastToken && okLen) submitBtn.classList.remove("hidden");
      else submitBtn.classList.add("hidden");
    }

    // Turnstile: Render warten
    function renderTurnstile(){
      const wait = () => {
        if (window.turnstile && typeof window.turnstile.render === "function") {
          widgetId = window.turnstile.render(turnstileWrapper, {
            sitekey: TURNSTILE_SITEKEY,
            callback: onTurnstileSuccess,
            "error-callback": onTurnstileError,
            "expired-callback": onTurnstileExpired
          });
        } else {
          setTimeout(wait, 200);
        }
      };
      wait();
    }

    function onTurnstileSuccess(token){
      lastToken = token;
      validateAndToggleSubmit();
    }
    function onTurnstileError(){ showToast("Captcha-Fehler, bitte erneut versuchen."); }
    function onTurnstileExpired(){ lastToken = null; validateAndToggleSubmit(); }

    // Submit
    submitBtn.addEventListener("click", async () => {
      clearError();
      submitBtn.disabled = true;
      sendingNote.classList.remove("hidden");

      const raw = messageEl.value || "";
      const cleanedForDisplay = raw.replace(/\r?\n/g, " ").trim();

      const payload = {
        bezeichnung: currentBezeichnung,
        token: lastToken,
        message: raw
      };

      try {
        const resp = await fetch(WORKER_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        let data = null;
        try { data = await resp.json(); } catch(e){ /* invalid json */ }

        if (!resp.ok) {
          const errMsg = (data && data.error) ? data.error : `Serverantwort ${resp.status}`;
          showToast(errMsg);
          return;
        }

        if (!data) {
          showToast("Ungültige Serverantwort");
          return;
        }

        if (data.status !== "SUCCESS") {
          const err = data.error || "Unbekannter Fehler";
          showToast(err);
          return;
        }

        // Erfolg
        sentBox.textContent = cleanedForDisplay || "(leere Nachricht)";
        resultArea.classList.remove("hidden");
        messageEl.value = "";
        charCount.textContent = "0 / 200";
        submitBtn.classList.add("hidden");
        lastToken = null;
        try {
          if (window.turnstile && typeof window.turnstile.reset === "function") {
            window.turnstile.reset(widgetId);
          }
        } catch(e){}
      } catch (err) {
        console.error(err);
        showToast("Netzwerkfehler: " + (err.message || err));
      } finally {
        submitBtn.disabled = false;
        sendingNote.classList.add("hidden");
      }
    });

    // copybox click
    sentBox.addEventListener("click", () => {
      const txt = sentBox.textContent || "";
      if (!txt) return;
      navigator.clipboard?.writeText(txt).then(() => {
        const prev = sentBox.textContent;
        sentBox.textContent = "Kopiert ✅ — " + prev;
        setTimeout(() => { sentBox.textContent = prev; }, 1400);
      }).catch(() => {
        try {
          const ta = document.createElement("textarea"); ta.value = txt; document.body.appendChild(ta); ta.select(); document.execCommand("copy"); document.body.removeChild(ta);
          const prev = sentBox.textContent;
          sentBox.textContent = "Kopiert ✅ — " + prev;
          setTimeout(() => { sentBox.textContent = prev; }, 1400);
        } catch(e) { showToast("Kopieren fehlgeschlagen"); }
      });
    });

    // Toast
    let toastTimer = null;
    function showToast(msg, ms = 4500) {
      toast.textContent = msg;
      toast.classList.add("show");
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(() => { toast.classList.remove("show"); }, ms);
    }

    function clearError(){ errorEl.classList.add("hidden"); errorEl.textContent = ""; }
    function showError(msg){ errorEl.textContent = msg; errorEl.classList.remove("hidden"); }

    // Enter mit Ctrl/Cmd senden
    messageEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
        if (!submitBtn.classList.contains("hidden")) submitBtn.click();
      }
    });

  })();
  </script>
</body>
</html>
